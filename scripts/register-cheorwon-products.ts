import * as fs from 'fs';
import * as path from 'path';

interface ScrapedProduct {
  id: string;
  name: string;
  price: string;
  originalPrice?: string;
  image: string;
  url: string;
  mall: string;
  region: string;
  category: string;
  inStock: boolean;
  scrapedAt: string;
}

interface DatabaseProduct {
  id: string;
  name: string;
  price: string;
  originalPrice?: string;
  image: string;
  url: string;
  mall: string;
  region: string;
  category: string;
  tags: string[];
  inStock: boolean;
  lastUpdated: string;
}

function generateTags(product: ScrapedProduct): string[] {
  const tags: string[] = [];
  
  const name = product.name.toLowerCase();
  
  if (name.includes('ÏåÄ') || name.includes('Ïò§ÎåÄÏåÄ')) {
    tags.push('ÏåÄ', 'Í≥°Î¨º', 'Ïò§ÎåÄÏåÄ');
  }
  if (name.includes('ÏöîÍ±∞Ìä∏') || name.includes('ÏπòÏ¶à')) {
    tags.push('Ïú†Ï†úÌíà', 'ÏöîÍ±∞Ìä∏', 'ÏπòÏ¶à');
  }
  if (name.includes('ÏãùÌòú')) {
    tags.push('ÏãùÌòú', 'ÏùåÎ£å', 'Ï†ÑÌÜµÏùåÎ£å');
  }
  if (name.includes('Î≤ÑÏÑØ') || name.includes('ÏÉÅÌô©Î≤ÑÏÑØ')) {
    tags.push('Î≤ÑÏÑØ', 'Í±¥Í∞ïÏãùÌíà', 'ÏÉÅÌô©Î≤ÑÏÑØ');
  }
  if (name.includes('Ïû£')) {
    tags.push('Ïû£', 'Í≤¨Í≥ºÎ•ò', 'Í±¥Í≥º');
  }
  if (name.includes('ÎèÑÎùºÏßÄ')) {
    tags.push('ÎèÑÎùºÏßÄ', 'Í±¥Í∞ïÏãùÌíà', 'Ï†ÑÌÜµÏ∞®');
  }
  if (name.includes('ÏÇ∞ÏÇº') || name.includes('ÏÇ∞ÏñëÏÇ∞ÏÇº')) {
    tags.push('ÏÇ∞ÏÇº', 'Í±¥Í∞ïÏãùÌíà', 'Ïù∏ÏÇº');
  }
  if (name.includes('Ìö®ÏÜå')) {
    tags.push('Ìö®ÏÜå', 'Í±¥Í∞ïÏãùÌíà', 'Î∞úÌö®ÏãùÌíà');
  }
  if (name.includes('ÏÇ¨Í≥º')) {
    tags.push('ÏÇ¨Í≥º', 'Í≥ºÏùº', 'Ïã†ÏÑ†Í≥ºÏùº');
  }
  if (name.includes('Ï∞êÎπµ') || name.includes('Ï£ºÏïÖ') || name.includes('ÌçºÏßÄ')) {
    tags.push('Í≥ºÏûê', 'Îñ°Î•ò', 'Ï†ÑÌÜµÍ≥ºÏûê');
  }
  if (name.includes('ÎßåÎëê')) {
    tags.push('ÎßåÎëê', 'ÎÉâÎèôÏãùÌíà', 'Í∞ÑÌé∏Ïãù');
  }
  if (name.includes('Í≥†Ï∂îÎÉâÏù¥')) {
    tags.push('Í≥†Ï∂îÎÉâÏù¥', 'Ï±ÑÏÜå', 'Ìñ•Ïã†Î£å');
  }
  if (name.includes('Îã≠Í∞àÎπÑ')) {
    tags.push('Îã≠Í∞àÎπÑ', 'Î∞ÄÌÇ§Ìä∏', 'Í∞ÑÌé∏Ïãù');
  }
  if (name.includes('Ï†ÑÌÜµÏ£º') || name.includes('ÌÉÅÏ£º')) {
    tags.push('Ï†ÑÌÜµÏ£º', 'Ïà†', 'ÏïåÏΩîÏò¨');
  }
  
  tags.push('Í∞ïÏõêÎèÑÌäπÏÇ∞Ìíà', 'Ï≤†ÏõêÌäπÏÇ∞Ìíà', 'ÎÜçÌäπÏÇ∞Î¨º');
  
  return [...new Set(tags)];
}

function convertToProductFormat(scrapedProduct: ScrapedProduct): DatabaseProduct {
  return {
    id: scrapedProduct.id,
    name: scrapedProduct.name,
    price: scrapedProduct.price,
    originalPrice: scrapedProduct.originalPrice,
    image: scrapedProduct.image,
    url: scrapedProduct.url,
    mall: scrapedProduct.mall,
    region: scrapedProduct.region,
    category: scrapedProduct.category,
    tags: generateTags(scrapedProduct),
    inStock: scrapedProduct.inStock,
    lastUpdated: new Date().toISOString()
  };
}

function registerCheorwonProducts(): void {
  try {
    console.log('üöÄ Starting Cheorwon Mall product registration...');
    
    const scriptsDir = path.dirname(__filename);
    const outputDir = path.join(scriptsDir, 'output');
    const scrapedProductsFile = path.join(outputDir, 'cheorwon-products.json');
    
    if (!fs.existsSync(scrapedProductsFile)) {
      throw new Error(`Scraped products file not found: ${scrapedProductsFile}`);
    }
    
    const scrapedProducts: ScrapedProduct[] = JSON.parse(
      fs.readFileSync(scrapedProductsFile, 'utf8')
    );
    
    console.log(`üìÇ Found ${scrapedProducts.length} scraped products`);
    
    const productsWithPrices = scrapedProducts.filter(product => 
      product.price && product.price.trim() !== ''
    );
    
    console.log(`üí∞ Products with prices: ${productsWithPrices.length}`);
    
    if (productsWithPrices.length === 0) {
      console.log('‚ùå No products with prices found. Registration aborted.');
      return;
    }
    
    const dataDir = path.join(scriptsDir, '..', 'src', 'data');
    const productsFile = path.join(dataDir, 'products.json');
    
    let existingProducts: DatabaseProduct[] = [];
    if (fs.existsSync(productsFile)) {
      existingProducts = JSON.parse(fs.readFileSync(productsFile, 'utf8'));
      console.log(`üìä Current database has ${existingProducts.length} products`);
    }
    
    const existingIds = new Set(existingProducts.map(p => p.id));
    const newProducts: DatabaseProduct[] = [];
    const updatedProducts: DatabaseProduct[] = [];
    
    for (const scrapedProduct of productsWithPrices) {
      const databaseProduct = convertToProductFormat(scrapedProduct);
      
      if (existingIds.has(databaseProduct.id)) {
        const existingIndex = existingProducts.findIndex(p => p.id === databaseProduct.id);
        if (existingIndex !== -1) {
          existingProducts[existingIndex] = databaseProduct;
          updatedProducts.push(databaseProduct);
        }
      } else {
        existingProducts.push(databaseProduct);
        newProducts.push(databaseProduct);
      }
    }
    
    const backupFile = path.join(dataDir, `products-backup-${Date.now()}.json`);
    if (fs.existsSync(productsFile)) {
      fs.copyFileSync(productsFile, backupFile);
      console.log(`üíæ Backup created: ${path.basename(backupFile)}`);
    }
    
    fs.writeFileSync(productsFile, JSON.stringify(existingProducts, null, 2), 'utf8');
    
    const registrationSummary = {
      mall: 'Ï≤†ÏõêÎ™∞',
      region: 'Í∞ïÏõêÎèÑ',
      scrapedProducts: scrapedProducts.length,
      productsWithPrices: productsWithPrices.length,
      newProducts: newProducts.length,
      updatedProducts: updatedProducts.length,
      totalProductsAfter: existingProducts.length,
      timestamp: new Date().toISOString(),
      backupFile: path.basename(backupFile),
      sampleNewProducts: newProducts.slice(0, 5).map(p => ({
        id: p.id,
        name: p.name,
        price: p.price,
        tags: p.tags
      })),
      categories: [...new Set(newProducts.map(p => p.category))],
      priceRange: {
        min: Math.min(...productsWithPrices.map(p => parseInt(p.price.replace(/[^0-9]/g, '')))),
        max: Math.max(...productsWithPrices.map(p => parseInt(p.price.replace(/[^0-9]/g, ''))))
      }
    };
    
    const summaryFile = path.join(outputDir, 'cheorwon-registration-summary.json');
    fs.writeFileSync(summaryFile, JSON.stringify(registrationSummary, null, 2), 'utf8');
    
    console.log('\nüéâ Cheorwon Mall product registration completed!');
    console.log(`üìä Registration Summary:`);
    console.log(`   ‚Ä¢ Scraped products: ${scrapedProducts.length}`);
    console.log(`   ‚Ä¢ Products with prices: ${productsWithPrices.length}`);
    console.log(`   ‚Ä¢ New products added: ${newProducts.length}`);
    console.log(`   ‚Ä¢ Updated products: ${updatedProducts.length}`);
    console.log(`   ‚Ä¢ Total products in database: ${existingProducts.length}`);
    console.log(`   ‚Ä¢ Price range: ${registrationSummary.priceRange.min.toLocaleString()}Ïõê - ${registrationSummary.priceRange.max.toLocaleString()}Ïõê`);
    
    if (newProducts.length > 0) {
      console.log(`\nüîç Sample new products:`);
      newProducts.slice(0, 3).forEach((product, index) => {
        console.log(`   ${index + 1}. ${product.name} - ${product.price}`);
        console.log(`      Tags: ${product.tags.join(', ')}`);
      });
    }
    
    console.log(`\nüìÅ Files updated:`);
    console.log(`   ‚Ä¢ Products database: ${productsFile}`);
    console.log(`   ‚Ä¢ Registration summary: ${summaryFile}`);
    console.log(`   ‚Ä¢ Backup: ${backupFile}`);
    
  } catch (error) {
    console.error('‚ùå Error during registration:', error);
    throw error;
  }
}

if (require.main === module) {
  registerCheorwonProducts();
}

export { registerCheorwonProducts };